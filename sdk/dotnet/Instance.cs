// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Linode
{
    public partial class Instance : Pulumi.CustomResource
    {
        [Output("alerts")]
        public Output<Outputs.InstanceAlerts> Alerts { get; private set; } = null!;

        /// <summary>
        /// A list of SSH public keys to deploy for the root user on the newly created Linode. Only accepted if `image` is provided. *This value can not be imported.* *Changing `authorized_keys` forces the creation of a new Linode Instance.*
        /// </summary>
        [Output("authorizedKeys")]
        public Output<ImmutableArray<string>> AuthorizedKeys { get; private set; } = null!;

        /// <summary>
        /// A list of Linode usernames. If the usernames have associated SSH keys, the keys will be appended to the `root` user's `~/.ssh/authorized_keys` file automatically. *This value can not be imported.* *Changing `authorized_users` forces the creation of a new Linode Instance.*
        /// </summary>
        [Output("authorizedUsers")]
        public Output<ImmutableArray<string>> AuthorizedUsers { get; private set; } = null!;

        /// <summary>
        /// A Backup ID from another Linode's available backups. Your User must have read_write access to that Linode, the Backup must have a status of successful, and the Linode must be deployed to the same region as the Backup. See /linode/instances/{linodeId}/backups for a Linode's available backups. This field and the image field are mutually exclusive. *This value can not be imported.* *Changing `backup_id` forces the creation of a new Linode Instance.*
        /// </summary>
        [Output("backupId")]
        public Output<int?> BackupId { get; private set; } = null!;

        /// <summary>
        /// Information about this Linode's backups status.
        /// </summary>
        [Output("backups")]
        public Output<Outputs.InstanceBackups> Backups { get; private set; } = null!;

        /// <summary>
        /// If this field is set to true, the created Linode will automatically be enrolled in the Linode Backup service. This will incur an additional charge. The cost for the Backup service is dependent on the Type of Linode deployed.
        /// </summary>
        [Output("backupsEnabled")]
        public Output<bool> BackupsEnabled { get; private set; } = null!;

        /// <summary>
        /// The Label of the Instance Config that should be used to boot the Linode instance.  If there is only one `config`, the `label` of that `config` will be used as the `boot_config_label`. *This value can not be imported.*
        /// </summary>
        [Output("bootConfigLabel")]
        public Output<string> BootConfigLabel { get; private set; } = null!;

        /// <summary>
        /// Configuration profiles define the VM settings and boot behavior of the Linode Instance.
        /// </summary>
        [Output("configs")]
        public Output<ImmutableArray<Outputs.InstanceConfigs>> Configs { get; private set; } = null!;

        [Output("disks")]
        public Output<ImmutableArray<Outputs.InstanceDisks>> Disks { get; private set; } = null!;

        /// <summary>
        /// The display group of the Linode instance.
        /// </summary>
        [Output("group")]
        public Output<string?> Group { get; private set; } = null!;

        /// <summary>
        /// An Image ID to deploy the Disk from. Official Linode Images start with linode/, while your Images start with private/. See /images for more information on the Images available for you to use. Examples are `linode/debian9`, `linode/fedora28`, `linode/ubuntu16.04lts`, `linode/arch`, and `private/12345`. *Changing `image` forces the creation of a new Linode Instance.*
        /// </summary>
        [Output("image")]
        public Output<string?> Image { get; private set; } = null!;

        /// <summary>
        /// This Linode's Public IPv4 Address. If there are multiple public IPv4 addresses on this Instance, an
        /// arbitrary address will be used for this field.
        /// </summary>
        [Output("ipAddress")]
        public Output<string> IpAddress { get; private set; } = null!;

        /// <summary>
        /// This Linode's IPv4 Addresses. Each Linode is assigned a single public IPv4 address upon creation, and may
        /// get a single private IPv4 address if needed. You may need to open a support ticket to get additional IPv4
        /// addresses.
        /// </summary>
        [Output("ipv4s")]
        public Output<ImmutableArray<string>> Ipv4s { get; private set; } = null!;

        /// <summary>
        /// This Linode's IPv6 SLAAC addresses. This address is specific to a Linode, and may not be shared.
        /// </summary>
        [Output("ipv6")]
        public Output<string> Ipv6 { get; private set; } = null!;

        /// <summary>
        /// The Config's label for display purposes.  Also used by `boot_config_label`.
        /// </summary>
        [Output("label")]
        public Output<string> Label { get; private set; } = null!;

        /// <summary>
        /// If true, the created Linode will have private networking enabled, allowing use of the 192.168.128.0/17 network within the Linode's region. It can be enabled on an existing Linode but it can't be disabled.
        /// </summary>
        [Output("privateIp")]
        public Output<bool?> PrivateIp { get; private set; } = null!;

        /// <summary>
        /// This Linode's Private IPv4 Address. The regional private IP address range is 192.168.128/17 address shared
        /// by all Linode Instances in a region.
        /// </summary>
        [Output("privateIpAddress")]
        public Output<string> PrivateIpAddress { get; private set; } = null!;

        /// <summary>
        /// This is the location where the Linode is deployed. Examples are `"us-east"`, `"us-west"`, `"ap-south"`, etc.  *Changing `region` forces the creation of a new Linode Instance.*.
        /// </summary>
        [Output("region")]
        public Output<string> Region { get; private set; } = null!;

        /// <summary>
        /// The password that will be initialially assigned to the 'root' user account.
        /// </summary>
        [Output("rootPass")]
        public Output<string?> RootPass { get; private set; } = null!;

        [Output("specs")]
        public Output<Outputs.InstanceSpecs> Specs { get; private set; } = null!;

        /// <summary>
        /// An object containing responses to any User Defined Fields present in the StackScript being deployed to this Linode. Only accepted if 'stackscript_id' is given. The required values depend on the StackScript being deployed.  *This value can not be imported.* *Changing `stackscript_data` forces the creation of a new Linode Instance.*
        /// </summary>
        [Output("stackscriptData")]
        public Output<ImmutableDictionary<string, string>?> StackscriptData { get; private set; } = null!;

        /// <summary>
        /// The StackScript to deploy to the newly created Linode. If provided, 'image' must also be provided, and must be an Image that is compatible with this StackScript. *This value can not be imported.* *Changing `stackscript_id` forces the creation of a new Linode Instance.*
        /// </summary>
        [Output("stackscriptId")]
        public Output<int?> StackscriptId { get; private set; } = null!;

        /// <summary>
        /// The status of the instance, indicating the current readiness state.
        /// </summary>
        [Output("status")]
        public Output<string> Status { get; private set; } = null!;

        /// <summary>
        /// When deploying from an Image, this field is optional with a Linode API default of 512mb, otherwise it is ignored. This is used to set the swap disk size for the newly-created Linode.
        /// </summary>
        [Output("swapSize")]
        public Output<int> SwapSize { get; private set; } = null!;

        /// <summary>
        /// A list of tags applied to this object. Tags are for organizational purposes only.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// The Linode type defines the pricing, CPU, disk, and RAM specs of the instance.  Examples are `"g6-nanode-1"`, `"g6-standard-2"`, `"g6-highmem-16"`, `"g6-dedicated-16"`, etc.
        /// </summary>
        [Output("type")]
        public Output<string?> Type { get; private set; } = null!;

        /// <summary>
        /// The watchdog, named Lassie, is a Shutdown Watchdog that monitors your Linode and will reboot it if it powers off unexpectedly. It works by issuing a boot job when your Linode powers off without a shutdown job being responsible. To prevent a loop, Lassie will give up if there have been more than 5 boot jobs issued within 15 minutes.
        /// </summary>
        [Output("watchdogEnabled")]
        public Output<bool?> WatchdogEnabled { get; private set; } = null!;


        /// <summary>
        /// Create a Instance resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Instance(string name, InstanceArgs args, CustomResourceOptions? options = null)
            : base("linode:index/instance:Instance", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private Instance(string name, Input<string> id, InstanceState? state = null, CustomResourceOptions? options = null)
            : base("linode:index/instance:Instance", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Instance resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Instance Get(string name, Input<string> id, InstanceState? state = null, CustomResourceOptions? options = null)
        {
            return new Instance(name, id, state, options);
        }
    }

    public sealed class InstanceArgs : Pulumi.ResourceArgs
    {
        [Input("alerts")]
        public Input<Inputs.InstanceAlertsArgs>? Alerts { get; set; }

        [Input("authorizedKeys")]
        private InputList<string>? _authorizedKeys;

        /// <summary>
        /// A list of SSH public keys to deploy for the root user on the newly created Linode. Only accepted if `image` is provided. *This value can not be imported.* *Changing `authorized_keys` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputList<string> AuthorizedKeys
        {
            get => _authorizedKeys ?? (_authorizedKeys = new InputList<string>());
            set => _authorizedKeys = value;
        }

        [Input("authorizedUsers")]
        private InputList<string>? _authorizedUsers;

        /// <summary>
        /// A list of Linode usernames. If the usernames have associated SSH keys, the keys will be appended to the `root` user's `~/.ssh/authorized_keys` file automatically. *This value can not be imported.* *Changing `authorized_users` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputList<string> AuthorizedUsers
        {
            get => _authorizedUsers ?? (_authorizedUsers = new InputList<string>());
            set => _authorizedUsers = value;
        }

        /// <summary>
        /// A Backup ID from another Linode's available backups. Your User must have read_write access to that Linode, the Backup must have a status of successful, and the Linode must be deployed to the same region as the Backup. See /linode/instances/{linodeId}/backups for a Linode's available backups. This field and the image field are mutually exclusive. *This value can not be imported.* *Changing `backup_id` forces the creation of a new Linode Instance.*
        /// </summary>
        [Input("backupId")]
        public Input<int>? BackupId { get; set; }

        /// <summary>
        /// If this field is set to true, the created Linode will automatically be enrolled in the Linode Backup service. This will incur an additional charge. The cost for the Backup service is dependent on the Type of Linode deployed.
        /// </summary>
        [Input("backupsEnabled")]
        public Input<bool>? BackupsEnabled { get; set; }

        /// <summary>
        /// The Label of the Instance Config that should be used to boot the Linode instance.  If there is only one `config`, the `label` of that `config` will be used as the `boot_config_label`. *This value can not be imported.*
        /// </summary>
        [Input("bootConfigLabel")]
        public Input<string>? BootConfigLabel { get; set; }

        [Input("configs")]
        private InputList<Inputs.InstanceConfigsArgs>? _configs;

        /// <summary>
        /// Configuration profiles define the VM settings and boot behavior of the Linode Instance.
        /// </summary>
        public InputList<Inputs.InstanceConfigsArgs> Configs
        {
            get => _configs ?? (_configs = new InputList<Inputs.InstanceConfigsArgs>());
            set => _configs = value;
        }

        [Input("disks")]
        private InputList<Inputs.InstanceDisksArgs>? _disks;
        public InputList<Inputs.InstanceDisksArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.InstanceDisksArgs>());
            set => _disks = value;
        }

        /// <summary>
        /// The display group of the Linode instance.
        /// </summary>
        [Input("group")]
        public Input<string>? Group { get; set; }

        /// <summary>
        /// An Image ID to deploy the Disk from. Official Linode Images start with linode/, while your Images start with private/. See /images for more information on the Images available for you to use. Examples are `linode/debian9`, `linode/fedora28`, `linode/ubuntu16.04lts`, `linode/arch`, and `private/12345`. *Changing `image` forces the creation of a new Linode Instance.*
        /// </summary>
        [Input("image")]
        public Input<string>? Image { get; set; }

        /// <summary>
        /// The Config's label for display purposes.  Also used by `boot_config_label`.
        /// </summary>
        [Input("label")]
        public Input<string>? Label { get; set; }

        /// <summary>
        /// If true, the created Linode will have private networking enabled, allowing use of the 192.168.128.0/17 network within the Linode's region. It can be enabled on an existing Linode but it can't be disabled.
        /// </summary>
        [Input("privateIp")]
        public Input<bool>? PrivateIp { get; set; }

        /// <summary>
        /// This is the location where the Linode is deployed. Examples are `"us-east"`, `"us-west"`, `"ap-south"`, etc.  *Changing `region` forces the creation of a new Linode Instance.*.
        /// </summary>
        [Input("region", required: true)]
        public Input<string> Region { get; set; } = null!;

        /// <summary>
        /// The password that will be initialially assigned to the 'root' user account.
        /// </summary>
        [Input("rootPass")]
        public Input<string>? RootPass { get; set; }

        [Input("stackscriptData")]
        private InputMap<string>? _stackscriptData;

        /// <summary>
        /// An object containing responses to any User Defined Fields present in the StackScript being deployed to this Linode. Only accepted if 'stackscript_id' is given. The required values depend on the StackScript being deployed.  *This value can not be imported.* *Changing `stackscript_data` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputMap<string> StackscriptData
        {
            get => _stackscriptData ?? (_stackscriptData = new InputMap<string>());
            set => _stackscriptData = value;
        }

        /// <summary>
        /// The StackScript to deploy to the newly created Linode. If provided, 'image' must also be provided, and must be an Image that is compatible with this StackScript. *This value can not be imported.* *Changing `stackscript_id` forces the creation of a new Linode Instance.*
        /// </summary>
        [Input("stackscriptId")]
        public Input<int>? StackscriptId { get; set; }

        /// <summary>
        /// When deploying from an Image, this field is optional with a Linode API default of 512mb, otherwise it is ignored. This is used to set the swap disk size for the newly-created Linode.
        /// </summary>
        [Input("swapSize")]
        public Input<int>? SwapSize { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of tags applied to this object. Tags are for organizational purposes only.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The Linode type defines the pricing, CPU, disk, and RAM specs of the instance.  Examples are `"g6-nanode-1"`, `"g6-standard-2"`, `"g6-highmem-16"`, `"g6-dedicated-16"`, etc.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// The watchdog, named Lassie, is a Shutdown Watchdog that monitors your Linode and will reboot it if it powers off unexpectedly. It works by issuing a boot job when your Linode powers off without a shutdown job being responsible. To prevent a loop, Lassie will give up if there have been more than 5 boot jobs issued within 15 minutes.
        /// </summary>
        [Input("watchdogEnabled")]
        public Input<bool>? WatchdogEnabled { get; set; }

        public InstanceArgs()
        {
        }
    }

    public sealed class InstanceState : Pulumi.ResourceArgs
    {
        [Input("alerts")]
        public Input<Inputs.InstanceAlertsGetArgs>? Alerts { get; set; }

        [Input("authorizedKeys")]
        private InputList<string>? _authorizedKeys;

        /// <summary>
        /// A list of SSH public keys to deploy for the root user on the newly created Linode. Only accepted if `image` is provided. *This value can not be imported.* *Changing `authorized_keys` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputList<string> AuthorizedKeys
        {
            get => _authorizedKeys ?? (_authorizedKeys = new InputList<string>());
            set => _authorizedKeys = value;
        }

        [Input("authorizedUsers")]
        private InputList<string>? _authorizedUsers;

        /// <summary>
        /// A list of Linode usernames. If the usernames have associated SSH keys, the keys will be appended to the `root` user's `~/.ssh/authorized_keys` file automatically. *This value can not be imported.* *Changing `authorized_users` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputList<string> AuthorizedUsers
        {
            get => _authorizedUsers ?? (_authorizedUsers = new InputList<string>());
            set => _authorizedUsers = value;
        }

        /// <summary>
        /// A Backup ID from another Linode's available backups. Your User must have read_write access to that Linode, the Backup must have a status of successful, and the Linode must be deployed to the same region as the Backup. See /linode/instances/{linodeId}/backups for a Linode's available backups. This field and the image field are mutually exclusive. *This value can not be imported.* *Changing `backup_id` forces the creation of a new Linode Instance.*
        /// </summary>
        [Input("backupId")]
        public Input<int>? BackupId { get; set; }

        /// <summary>
        /// Information about this Linode's backups status.
        /// </summary>
        [Input("backups")]
        public Input<Inputs.InstanceBackupsGetArgs>? Backups { get; set; }

        /// <summary>
        /// If this field is set to true, the created Linode will automatically be enrolled in the Linode Backup service. This will incur an additional charge. The cost for the Backup service is dependent on the Type of Linode deployed.
        /// </summary>
        [Input("backupsEnabled")]
        public Input<bool>? BackupsEnabled { get; set; }

        /// <summary>
        /// The Label of the Instance Config that should be used to boot the Linode instance.  If there is only one `config`, the `label` of that `config` will be used as the `boot_config_label`. *This value can not be imported.*
        /// </summary>
        [Input("bootConfigLabel")]
        public Input<string>? BootConfigLabel { get; set; }

        [Input("configs")]
        private InputList<Inputs.InstanceConfigsGetArgs>? _configs;

        /// <summary>
        /// Configuration profiles define the VM settings and boot behavior of the Linode Instance.
        /// </summary>
        public InputList<Inputs.InstanceConfigsGetArgs> Configs
        {
            get => _configs ?? (_configs = new InputList<Inputs.InstanceConfigsGetArgs>());
            set => _configs = value;
        }

        [Input("disks")]
        private InputList<Inputs.InstanceDisksGetArgs>? _disks;
        public InputList<Inputs.InstanceDisksGetArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.InstanceDisksGetArgs>());
            set => _disks = value;
        }

        /// <summary>
        /// The display group of the Linode instance.
        /// </summary>
        [Input("group")]
        public Input<string>? Group { get; set; }

        /// <summary>
        /// An Image ID to deploy the Disk from. Official Linode Images start with linode/, while your Images start with private/. See /images for more information on the Images available for you to use. Examples are `linode/debian9`, `linode/fedora28`, `linode/ubuntu16.04lts`, `linode/arch`, and `private/12345`. *Changing `image` forces the creation of a new Linode Instance.*
        /// </summary>
        [Input("image")]
        public Input<string>? Image { get; set; }

        /// <summary>
        /// This Linode's Public IPv4 Address. If there are multiple public IPv4 addresses on this Instance, an
        /// arbitrary address will be used for this field.
        /// </summary>
        [Input("ipAddress")]
        public Input<string>? IpAddress { get; set; }

        [Input("ipv4s")]
        private InputList<string>? _ipv4s;

        /// <summary>
        /// This Linode's IPv4 Addresses. Each Linode is assigned a single public IPv4 address upon creation, and may
        /// get a single private IPv4 address if needed. You may need to open a support ticket to get additional IPv4
        /// addresses.
        /// </summary>
        public InputList<string> Ipv4s
        {
            get => _ipv4s ?? (_ipv4s = new InputList<string>());
            set => _ipv4s = value;
        }

        /// <summary>
        /// This Linode's IPv6 SLAAC addresses. This address is specific to a Linode, and may not be shared.
        /// </summary>
        [Input("ipv6")]
        public Input<string>? Ipv6 { get; set; }

        /// <summary>
        /// The Config's label for display purposes.  Also used by `boot_config_label`.
        /// </summary>
        [Input("label")]
        public Input<string>? Label { get; set; }

        /// <summary>
        /// If true, the created Linode will have private networking enabled, allowing use of the 192.168.128.0/17 network within the Linode's region. It can be enabled on an existing Linode but it can't be disabled.
        /// </summary>
        [Input("privateIp")]
        public Input<bool>? PrivateIp { get; set; }

        /// <summary>
        /// This Linode's Private IPv4 Address. The regional private IP address range is 192.168.128/17 address shared
        /// by all Linode Instances in a region.
        /// </summary>
        [Input("privateIpAddress")]
        public Input<string>? PrivateIpAddress { get; set; }

        /// <summary>
        /// This is the location where the Linode is deployed. Examples are `"us-east"`, `"us-west"`, `"ap-south"`, etc.  *Changing `region` forces the creation of a new Linode Instance.*.
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// The password that will be initialially assigned to the 'root' user account.
        /// </summary>
        [Input("rootPass")]
        public Input<string>? RootPass { get; set; }

        [Input("specs")]
        public Input<Inputs.InstanceSpecsGetArgs>? Specs { get; set; }

        [Input("stackscriptData")]
        private InputMap<string>? _stackscriptData;

        /// <summary>
        /// An object containing responses to any User Defined Fields present in the StackScript being deployed to this Linode. Only accepted if 'stackscript_id' is given. The required values depend on the StackScript being deployed.  *This value can not be imported.* *Changing `stackscript_data` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputMap<string> StackscriptData
        {
            get => _stackscriptData ?? (_stackscriptData = new InputMap<string>());
            set => _stackscriptData = value;
        }

        /// <summary>
        /// The StackScript to deploy to the newly created Linode. If provided, 'image' must also be provided, and must be an Image that is compatible with this StackScript. *This value can not be imported.* *Changing `stackscript_id` forces the creation of a new Linode Instance.*
        /// </summary>
        [Input("stackscriptId")]
        public Input<int>? StackscriptId { get; set; }

        /// <summary>
        /// The status of the instance, indicating the current readiness state.
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// When deploying from an Image, this field is optional with a Linode API default of 512mb, otherwise it is ignored. This is used to set the swap disk size for the newly-created Linode.
        /// </summary>
        [Input("swapSize")]
        public Input<int>? SwapSize { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of tags applied to this object. Tags are for organizational purposes only.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The Linode type defines the pricing, CPU, disk, and RAM specs of the instance.  Examples are `"g6-nanode-1"`, `"g6-standard-2"`, `"g6-highmem-16"`, `"g6-dedicated-16"`, etc.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// The watchdog, named Lassie, is a Shutdown Watchdog that monitors your Linode and will reboot it if it powers off unexpectedly. It works by issuing a boot job when your Linode powers off without a shutdown job being responsible. To prevent a loop, Lassie will give up if there have been more than 5 boot jobs issued within 15 minutes.
        /// </summary>
        [Input("watchdogEnabled")]
        public Input<bool>? WatchdogEnabled { get; set; }

        public InstanceState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class InstanceAlertsArgs : Pulumi.ResourceArgs
    {
        [Input("cpu")]
        public Input<int>? Cpu { get; set; }

        [Input("io")]
        public Input<int>? Io { get; set; }

        [Input("networkIn")]
        public Input<int>? NetworkIn { get; set; }

        [Input("networkOut")]
        public Input<int>? NetworkOut { get; set; }

        [Input("transferQuota")]
        public Input<int>? TransferQuota { get; set; }

        public InstanceAlertsArgs()
        {
        }
    }

    public sealed class InstanceAlertsGetArgs : Pulumi.ResourceArgs
    {
        [Input("cpu")]
        public Input<int>? Cpu { get; set; }

        [Input("io")]
        public Input<int>? Io { get; set; }

        [Input("networkIn")]
        public Input<int>? NetworkIn { get; set; }

        [Input("networkOut")]
        public Input<int>? NetworkOut { get; set; }

        [Input("transferQuota")]
        public Input<int>? TransferQuota { get; set; }

        public InstanceAlertsGetArgs()
        {
        }
    }

    public sealed class InstanceBackupsGetArgs : Pulumi.ResourceArgs
    {
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        [Input("schedule")]
        public Input<InstanceBackupsScheduleGetArgs>? Schedule { get; set; }

        public InstanceBackupsGetArgs()
        {
        }
    }

    public sealed class InstanceBackupsScheduleGetArgs : Pulumi.ResourceArgs
    {
        [Input("day")]
        public Input<string>? Day { get; set; }

        [Input("window")]
        public Input<string>? Window { get; set; }

        public InstanceBackupsScheduleGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// - Arbitrary user comments about this `config`.
        /// </summary>
        [Input("comments")]
        public Input<string>? Comments { get; set; }

        /// <summary>
        /// A list of `disk` or `volume` attachments for this `config`.  If the `boot_config_label` omits a `devices` block, the Linode will not be booted.
        /// </summary>
        [Input("devices")]
        public Input<InstanceConfigsDevicesArgs>? Devices { get; set; }

        /// <summary>
        /// Helpers enabled when booting to this Linode Config.
        /// </summary>
        [Input("helpers")]
        public Input<InstanceConfigsHelpersArgs>? Helpers { get; set; }

        /// <summary>
        /// - A Kernel ID to boot a Linode with. Default is based on image choice. (examples: linode/latest-64bit, linode/grub2, linode/direct-disk)
        /// </summary>
        [Input("kernel")]
        public Input<string>? Kernel { get; set; }

        /// <summary>
        /// The Config's label for display purposes.  Also used by `boot_config_label`.
        /// </summary>
        [Input("label", required: true)]
        public Input<string> Label { get; set; } = null!;

        /// <summary>
        /// - Defaults to the total RAM of the Linode
        /// </summary>
        [Input("memoryLimit")]
        public Input<int>? MemoryLimit { get; set; }

        /// <summary>
        /// - The root device to boot. The corresponding disk must be attached to a `device` slot.  Example: `"/dev/sda"`
        /// </summary>
        [Input("rootDevice")]
        public Input<string>? RootDevice { get; set; }

        /// <summary>
        /// - Defines the state of your Linode after booting. Defaults to `"default"`.
        /// </summary>
        [Input("runLevel")]
        public Input<string>? RunLevel { get; set; }

        /// <summary>
        /// - Controls the virtualization mode. Defaults to `"paravirt"`.
        /// </summary>
        [Input("virtMode")]
        public Input<string>? VirtMode { get; set; }

        public InstanceConfigsArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesArgs : Pulumi.ResourceArgs
    {
        [Input("sda")]
        public Input<InstanceConfigsDevicesSdaArgs>? Sda { get; set; }

        [Input("sdb")]
        public Input<InstanceConfigsDevicesSdbArgs>? Sdb { get; set; }

        [Input("sdc")]
        public Input<InstanceConfigsDevicesSdcArgs>? Sdc { get; set; }

        [Input("sdd")]
        public Input<InstanceConfigsDevicesSddArgs>? Sdd { get; set; }

        [Input("sde")]
        public Input<InstanceConfigsDevicesSdeArgs>? Sde { get; set; }

        [Input("sdf")]
        public Input<InstanceConfigsDevicesSdfArgs>? Sdf { get; set; }

        [Input("sdg")]
        public Input<InstanceConfigsDevicesSdgArgs>? Sdg { get; set; }

        [Input("sdh")]
        public Input<InstanceConfigsDevicesSdhArgs>? Sdh { get; set; }

        public InstanceConfigsDevicesArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesGetArgs : Pulumi.ResourceArgs
    {
        [Input("sda")]
        public Input<InstanceConfigsDevicesSdaGetArgs>? Sda { get; set; }

        [Input("sdb")]
        public Input<InstanceConfigsDevicesSdbGetArgs>? Sdb { get; set; }

        [Input("sdc")]
        public Input<InstanceConfigsDevicesSdcGetArgs>? Sdc { get; set; }

        [Input("sdd")]
        public Input<InstanceConfigsDevicesSddGetArgs>? Sdd { get; set; }

        [Input("sde")]
        public Input<InstanceConfigsDevicesSdeGetArgs>? Sde { get; set; }

        [Input("sdf")]
        public Input<InstanceConfigsDevicesSdfGetArgs>? Sdf { get; set; }

        [Input("sdg")]
        public Input<InstanceConfigsDevicesSdgGetArgs>? Sdg { get; set; }

        [Input("sdh")]
        public Input<InstanceConfigsDevicesSdhGetArgs>? Sdh { get; set; }

        public InstanceConfigsDevicesGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdaArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdaArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdaGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdaGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdbArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdbArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdbGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdbGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdcArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdcArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdcGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdcGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSddArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSddArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSddGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSddGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdeArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdeArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdeGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdeGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdfArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdfArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdfGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdfGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdgArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdgArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdgGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdgGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdhArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdhArgs()
        {
        }
    }

    public sealed class InstanceConfigsDevicesSdhGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        [Input("diskId")]
        public Input<int>? DiskId { get; set; }

        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        [Input("diskLabel")]
        public Input<string>? DiskLabel { get; set; }

        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        [Input("volumeId")]
        public Input<int>? VolumeId { get; set; }

        public InstanceConfigsDevicesSdhGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// - Arbitrary user comments about this `config`.
        /// </summary>
        [Input("comments")]
        public Input<string>? Comments { get; set; }

        /// <summary>
        /// A list of `disk` or `volume` attachments for this `config`.  If the `boot_config_label` omits a `devices` block, the Linode will not be booted.
        /// </summary>
        [Input("devices")]
        public Input<InstanceConfigsDevicesGetArgs>? Devices { get; set; }

        /// <summary>
        /// Helpers enabled when booting to this Linode Config.
        /// </summary>
        [Input("helpers")]
        public Input<InstanceConfigsHelpersGetArgs>? Helpers { get; set; }

        /// <summary>
        /// - A Kernel ID to boot a Linode with. Default is based on image choice. (examples: linode/latest-64bit, linode/grub2, linode/direct-disk)
        /// </summary>
        [Input("kernel")]
        public Input<string>? Kernel { get; set; }

        /// <summary>
        /// The Config's label for display purposes.  Also used by `boot_config_label`.
        /// </summary>
        [Input("label", required: true)]
        public Input<string> Label { get; set; } = null!;

        /// <summary>
        /// - Defaults to the total RAM of the Linode
        /// </summary>
        [Input("memoryLimit")]
        public Input<int>? MemoryLimit { get; set; }

        /// <summary>
        /// - The root device to boot. The corresponding disk must be attached to a `device` slot.  Example: `"/dev/sda"`
        /// </summary>
        [Input("rootDevice")]
        public Input<string>? RootDevice { get; set; }

        /// <summary>
        /// - Defines the state of your Linode after booting. Defaults to `"default"`.
        /// </summary>
        [Input("runLevel")]
        public Input<string>? RunLevel { get; set; }

        /// <summary>
        /// - Controls the virtualization mode. Defaults to `"paravirt"`.
        /// </summary>
        [Input("virtMode")]
        public Input<string>? VirtMode { get; set; }

        public InstanceConfigsGetArgs()
        {
        }
    }

    public sealed class InstanceConfigsHelpersArgs : Pulumi.ResourceArgs
    {
        [Input("devtmpfsAutomount")]
        public Input<bool>? DevtmpfsAutomount { get; set; }

        /// <summary>
        /// Controls the behavior of the Linode Config's Distribution Helper setting.
        /// </summary>
        [Input("distro")]
        public Input<bool>? Distro { get; set; }

        /// <summary>
        /// Creates a modules dependency file for the Kernel you run.
        /// </summary>
        [Input("modulesDep")]
        public Input<bool>? ModulesDep { get; set; }

        /// <summary>
        /// Controls the behavior of the Linode Config's Network Helper setting, used to automatically configure additional IP addresses assigned to this instance.
        /// </summary>
        [Input("network")]
        public Input<bool>? Network { get; set; }

        /// <summary>
        /// Disables updatedb cron job to avoid disk thrashing.
        /// </summary>
        [Input("updatedbDisabled")]
        public Input<bool>? UpdatedbDisabled { get; set; }

        public InstanceConfigsHelpersArgs()
        {
        }
    }

    public sealed class InstanceConfigsHelpersGetArgs : Pulumi.ResourceArgs
    {
        [Input("devtmpfsAutomount")]
        public Input<bool>? DevtmpfsAutomount { get; set; }

        /// <summary>
        /// Controls the behavior of the Linode Config's Distribution Helper setting.
        /// </summary>
        [Input("distro")]
        public Input<bool>? Distro { get; set; }

        /// <summary>
        /// Creates a modules dependency file for the Kernel you run.
        /// </summary>
        [Input("modulesDep")]
        public Input<bool>? ModulesDep { get; set; }

        /// <summary>
        /// Controls the behavior of the Linode Config's Network Helper setting, used to automatically configure additional IP addresses assigned to this instance.
        /// </summary>
        [Input("network")]
        public Input<bool>? Network { get; set; }

        /// <summary>
        /// Disables updatedb cron job to avoid disk thrashing.
        /// </summary>
        [Input("updatedbDisabled")]
        public Input<bool>? UpdatedbDisabled { get; set; }

        public InstanceConfigsHelpersGetArgs()
        {
        }
    }

    public sealed class InstanceDisksArgs : Pulumi.ResourceArgs
    {
        [Input("authorizedKeys")]
        private InputList<string>? _authorizedKeys;

        /// <summary>
        /// A list of SSH public keys to deploy for the root user on the newly created Linode. Only accepted if `image` is provided. *This value can not be imported.* *Changing `authorized_keys` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputList<string> AuthorizedKeys
        {
            get => _authorizedKeys ?? (_authorizedKeys = new InputList<string>());
            set => _authorizedKeys = value;
        }

        [Input("authorizedUsers")]
        private InputList<string>? _authorizedUsers;

        /// <summary>
        /// A list of Linode usernames. If the usernames have associated SSH keys, the keys will be appended to the `root` user's `~/.ssh/authorized_keys` file automatically. *This value can not be imported.* *Changing `authorized_users` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputList<string> AuthorizedUsers
        {
            get => _authorizedUsers ?? (_authorizedUsers = new InputList<string>());
            set => _authorizedUsers = value;
        }

        [Input("filesystem")]
        public Input<string>? Filesystem { get; set; }

        /// <summary>
        /// The ID of the disk in the Linode API.
        /// </summary>
        [Input("id")]
        public Input<int>? Id { get; set; }

        /// <summary>
        /// An Image ID to deploy the Disk from. Official Linode Images start with linode/, while your Images start with private/. See /images for more information on the Images available for you to use. Examples are `linode/debian9`, `linode/fedora28`, `linode/ubuntu16.04lts`, `linode/arch`, and `private/12345`. *Changing `image` forces the creation of a new Linode Instance.*
        /// </summary>
        [Input("image")]
        public Input<string>? Image { get; set; }

        /// <summary>
        /// The Config's label for display purposes.  Also used by `boot_config_label`.
        /// </summary>
        [Input("label", required: true)]
        public Input<string> Label { get; set; } = null!;

        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        [Input("rootPass")]
        public Input<string>? RootPass { get; set; }

        /// <summary>
        /// The size of the Disk in MB.
        /// </summary>
        [Input("size", required: true)]
        public Input<int> Size { get; set; } = null!;

        [Input("stackscriptData")]
        private InputMap<object>? _stackscriptData;

        /// <summary>
        /// An object containing responses to any User Defined Fields present in the StackScript being deployed to this Linode. Only accepted if 'stackscript_id' is given. The required values depend on the StackScript being deployed.  *This value can not be imported.* *Changing `stackscript_data` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputMap<object> StackscriptData
        {
            get => _stackscriptData ?? (_stackscriptData = new InputMap<object>());
            set => _stackscriptData = value;
        }

        /// <summary>
        /// The StackScript to deploy to the newly created Linode. If provided, 'image' must also be provided, and must be an Image that is compatible with this StackScript. *This value can not be imported.* *Changing `stackscript_id` forces the creation of a new Linode Instance.*
        /// </summary>
        [Input("stackscriptId")]
        public Input<int>? StackscriptId { get; set; }

        public InstanceDisksArgs()
        {
        }
    }

    public sealed class InstanceDisksGetArgs : Pulumi.ResourceArgs
    {
        [Input("authorizedKeys")]
        private InputList<string>? _authorizedKeys;

        /// <summary>
        /// A list of SSH public keys to deploy for the root user on the newly created Linode. Only accepted if `image` is provided. *This value can not be imported.* *Changing `authorized_keys` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputList<string> AuthorizedKeys
        {
            get => _authorizedKeys ?? (_authorizedKeys = new InputList<string>());
            set => _authorizedKeys = value;
        }

        [Input("authorizedUsers")]
        private InputList<string>? _authorizedUsers;

        /// <summary>
        /// A list of Linode usernames. If the usernames have associated SSH keys, the keys will be appended to the `root` user's `~/.ssh/authorized_keys` file automatically. *This value can not be imported.* *Changing `authorized_users` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputList<string> AuthorizedUsers
        {
            get => _authorizedUsers ?? (_authorizedUsers = new InputList<string>());
            set => _authorizedUsers = value;
        }

        [Input("filesystem")]
        public Input<string>? Filesystem { get; set; }

        /// <summary>
        /// The ID of the disk in the Linode API.
        /// </summary>
        [Input("id")]
        public Input<int>? Id { get; set; }

        /// <summary>
        /// An Image ID to deploy the Disk from. Official Linode Images start with linode/, while your Images start with private/. See /images for more information on the Images available for you to use. Examples are `linode/debian9`, `linode/fedora28`, `linode/ubuntu16.04lts`, `linode/arch`, and `private/12345`. *Changing `image` forces the creation of a new Linode Instance.*
        /// </summary>
        [Input("image")]
        public Input<string>? Image { get; set; }

        /// <summary>
        /// The Config's label for display purposes.  Also used by `boot_config_label`.
        /// </summary>
        [Input("label", required: true)]
        public Input<string> Label { get; set; } = null!;

        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        [Input("rootPass")]
        public Input<string>? RootPass { get; set; }

        /// <summary>
        /// The size of the Disk in MB.
        /// </summary>
        [Input("size", required: true)]
        public Input<int> Size { get; set; } = null!;

        [Input("stackscriptData")]
        private InputMap<object>? _stackscriptData;

        /// <summary>
        /// An object containing responses to any User Defined Fields present in the StackScript being deployed to this Linode. Only accepted if 'stackscript_id' is given. The required values depend on the StackScript being deployed.  *This value can not be imported.* *Changing `stackscript_data` forces the creation of a new Linode Instance.*
        /// </summary>
        public InputMap<object> StackscriptData
        {
            get => _stackscriptData ?? (_stackscriptData = new InputMap<object>());
            set => _stackscriptData = value;
        }

        /// <summary>
        /// The StackScript to deploy to the newly created Linode. If provided, 'image' must also be provided, and must be an Image that is compatible with this StackScript. *This value can not be imported.* *Changing `stackscript_id` forces the creation of a new Linode Instance.*
        /// </summary>
        [Input("stackscriptId")]
        public Input<int>? StackscriptId { get; set; }

        public InstanceDisksGetArgs()
        {
        }
    }

    public sealed class InstanceSpecsGetArgs : Pulumi.ResourceArgs
    {
        [Input("disk")]
        public Input<int>? Disk { get; set; }

        [Input("memory")]
        public Input<int>? Memory { get; set; }

        [Input("transfer")]
        public Input<int>? Transfer { get; set; }

        [Input("vcpus")]
        public Input<int>? Vcpus { get; set; }

        public InstanceSpecsGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class InstanceAlerts
    {
        public readonly int Cpu;
        public readonly int Io;
        public readonly int NetworkIn;
        public readonly int NetworkOut;
        public readonly int TransferQuota;

        [OutputConstructor]
        private InstanceAlerts(
            int cpu,
            int io,
            int networkIn,
            int networkOut,
            int transferQuota)
        {
            Cpu = cpu;
            Io = io;
            NetworkIn = networkIn;
            NetworkOut = networkOut;
            TransferQuota = transferQuota;
        }
    }

    [OutputType]
    public sealed class InstanceBackups
    {
        public readonly bool Enabled;
        public readonly InstanceBackupsSchedule Schedule;

        [OutputConstructor]
        private InstanceBackups(
            bool enabled,
            InstanceBackupsSchedule schedule)
        {
            Enabled = enabled;
            Schedule = schedule;
        }
    }

    [OutputType]
    public sealed class InstanceBackupsSchedule
    {
        public readonly string Day;
        public readonly string Window;

        [OutputConstructor]
        private InstanceBackupsSchedule(
            string day,
            string window)
        {
            Day = day;
            Window = window;
        }
    }

    [OutputType]
    public sealed class InstanceConfigs
    {
        /// <summary>
        /// - Arbitrary user comments about this `config`.
        /// </summary>
        public readonly string? Comments;
        /// <summary>
        /// A list of `disk` or `volume` attachments for this `config`.  If the `boot_config_label` omits a `devices` block, the Linode will not be booted.
        /// </summary>
        public readonly InstanceConfigsDevices Devices;
        /// <summary>
        /// Helpers enabled when booting to this Linode Config.
        /// </summary>
        public readonly InstanceConfigsHelpers Helpers;
        /// <summary>
        /// - A Kernel ID to boot a Linode with. Default is based on image choice. (examples: linode/latest-64bit, linode/grub2, linode/direct-disk)
        /// </summary>
        public readonly string? Kernel;
        /// <summary>
        /// The Config's label for display purposes.  Also used by `boot_config_label`.
        /// </summary>
        public readonly string Label;
        /// <summary>
        /// - Defaults to the total RAM of the Linode
        /// </summary>
        public readonly int? MemoryLimit;
        /// <summary>
        /// - The root device to boot. The corresponding disk must be attached to a `device` slot.  Example: `"/dev/sda"`
        /// </summary>
        public readonly string RootDevice;
        /// <summary>
        /// - Defines the state of your Linode after booting. Defaults to `"default"`.
        /// </summary>
        public readonly string? RunLevel;
        /// <summary>
        /// - Controls the virtualization mode. Defaults to `"paravirt"`.
        /// </summary>
        public readonly string? VirtMode;

        [OutputConstructor]
        private InstanceConfigs(
            string? comments,
            InstanceConfigsDevices devices,
            InstanceConfigsHelpers helpers,
            string? kernel,
            string label,
            int? memoryLimit,
            string rootDevice,
            string? runLevel,
            string? virtMode)
        {
            Comments = comments;
            Devices = devices;
            Helpers = helpers;
            Kernel = kernel;
            Label = label;
            MemoryLimit = memoryLimit;
            RootDevice = rootDevice;
            RunLevel = runLevel;
            VirtMode = virtMode;
        }
    }

    [OutputType]
    public sealed class InstanceConfigsDevices
    {
        public readonly InstanceConfigsDevicesSda Sda;
        public readonly InstanceConfigsDevicesSdb Sdb;
        public readonly InstanceConfigsDevicesSdc Sdc;
        public readonly InstanceConfigsDevicesSdd Sdd;
        public readonly InstanceConfigsDevicesSde Sde;
        public readonly InstanceConfigsDevicesSdf Sdf;
        public readonly InstanceConfigsDevicesSdg Sdg;
        public readonly InstanceConfigsDevicesSdh Sdh;

        [OutputConstructor]
        private InstanceConfigsDevices(
            InstanceConfigsDevicesSda sda,
            InstanceConfigsDevicesSdb sdb,
            InstanceConfigsDevicesSdc sdc,
            InstanceConfigsDevicesSdd sdd,
            InstanceConfigsDevicesSde sde,
            InstanceConfigsDevicesSdf sdf,
            InstanceConfigsDevicesSdg sdg,
            InstanceConfigsDevicesSdh sdh)
        {
            Sda = sda;
            Sdb = sdb;
            Sdc = sdc;
            Sdd = sdd;
            Sde = sde;
            Sdf = sdf;
            Sdg = sdg;
            Sdh = sdh;
        }
    }

    [OutputType]
    public sealed class InstanceConfigsDevicesSda
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        public readonly int DiskId;
        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        public readonly string? DiskLabel;
        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        public readonly int? VolumeId;

        [OutputConstructor]
        private InstanceConfigsDevicesSda(
            int diskId,
            string? diskLabel,
            int? volumeId)
        {
            DiskId = diskId;
            DiskLabel = diskLabel;
            VolumeId = volumeId;
        }
    }

    [OutputType]
    public sealed class InstanceConfigsDevicesSdb
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        public readonly int DiskId;
        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        public readonly string? DiskLabel;
        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        public readonly int? VolumeId;

        [OutputConstructor]
        private InstanceConfigsDevicesSdb(
            int diskId,
            string? diskLabel,
            int? volumeId)
        {
            DiskId = diskId;
            DiskLabel = diskLabel;
            VolumeId = volumeId;
        }
    }

    [OutputType]
    public sealed class InstanceConfigsDevicesSdc
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        public readonly int DiskId;
        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        public readonly string? DiskLabel;
        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        public readonly int? VolumeId;

        [OutputConstructor]
        private InstanceConfigsDevicesSdc(
            int diskId,
            string? diskLabel,
            int? volumeId)
        {
            DiskId = diskId;
            DiskLabel = diskLabel;
            VolumeId = volumeId;
        }
    }

    [OutputType]
    public sealed class InstanceConfigsDevicesSdd
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        public readonly int DiskId;
        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        public readonly string? DiskLabel;
        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        public readonly int? VolumeId;

        [OutputConstructor]
        private InstanceConfigsDevicesSdd(
            int diskId,
            string? diskLabel,
            int? volumeId)
        {
            DiskId = diskId;
            DiskLabel = diskLabel;
            VolumeId = volumeId;
        }
    }

    [OutputType]
    public sealed class InstanceConfigsDevicesSde
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        public readonly int DiskId;
        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        public readonly string? DiskLabel;
        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        public readonly int? VolumeId;

        [OutputConstructor]
        private InstanceConfigsDevicesSde(
            int diskId,
            string? diskLabel,
            int? volumeId)
        {
            DiskId = diskId;
            DiskLabel = diskLabel;
            VolumeId = volumeId;
        }
    }

    [OutputType]
    public sealed class InstanceConfigsDevicesSdf
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        public readonly int DiskId;
        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        public readonly string? DiskLabel;
        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        public readonly int? VolumeId;

        [OutputConstructor]
        private InstanceConfigsDevicesSdf(
            int diskId,
            string? diskLabel,
            int? volumeId)
        {
            DiskId = diskId;
            DiskLabel = diskLabel;
            VolumeId = volumeId;
        }
    }

    [OutputType]
    public sealed class InstanceConfigsDevicesSdg
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        public readonly int DiskId;
        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        public readonly string? DiskLabel;
        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        public readonly int? VolumeId;

        [OutputConstructor]
        private InstanceConfigsDevicesSdg(
            int diskId,
            string? diskLabel,
            int? volumeId)
        {
            DiskId = diskId;
            DiskLabel = diskLabel;
            VolumeId = volumeId;
        }
    }

    [OutputType]
    public sealed class InstanceConfigsDevicesSdh
    {
        /// <summary>
        /// The Disk ID of the associated `disk_label`, if used.
        /// </summary>
        public readonly int DiskId;
        /// <summary>
        /// The `label` of the `disk` to map to this `device` slot.
        /// </summary>
        public readonly string? DiskLabel;
        /// <summary>
        /// The Volume ID to map to this `device` slot.
        /// </summary>
        public readonly int? VolumeId;

        [OutputConstructor]
        private InstanceConfigsDevicesSdh(
            int diskId,
            string? diskLabel,
            int? volumeId)
        {
            DiskId = diskId;
            DiskLabel = diskLabel;
            VolumeId = volumeId;
        }
    }

    [OutputType]
    public sealed class InstanceConfigsHelpers
    {
        public readonly bool? DevtmpfsAutomount;
        /// <summary>
        /// Controls the behavior of the Linode Config's Distribution Helper setting.
        /// </summary>
        public readonly bool? Distro;
        /// <summary>
        /// Creates a modules dependency file for the Kernel you run.
        /// </summary>
        public readonly bool? ModulesDep;
        /// <summary>
        /// Controls the behavior of the Linode Config's Network Helper setting, used to automatically configure additional IP addresses assigned to this instance.
        /// </summary>
        public readonly bool? Network;
        /// <summary>
        /// Disables updatedb cron job to avoid disk thrashing.
        /// </summary>
        public readonly bool? UpdatedbDisabled;

        [OutputConstructor]
        private InstanceConfigsHelpers(
            bool? devtmpfsAutomount,
            bool? distro,
            bool? modulesDep,
            bool? network,
            bool? updatedbDisabled)
        {
            DevtmpfsAutomount = devtmpfsAutomount;
            Distro = distro;
            ModulesDep = modulesDep;
            Network = network;
            UpdatedbDisabled = updatedbDisabled;
        }
    }

    [OutputType]
    public sealed class InstanceDisks
    {
        /// <summary>
        /// A list of SSH public keys to deploy for the root user on the newly created Linode. Only accepted if `image` is provided. *This value can not be imported.* *Changing `authorized_keys` forces the creation of a new Linode Instance.*
        /// </summary>
        public readonly ImmutableArray<string> AuthorizedKeys;
        /// <summary>
        /// A list of Linode usernames. If the usernames have associated SSH keys, the keys will be appended to the `root` user's `~/.ssh/authorized_keys` file automatically. *This value can not be imported.* *Changing `authorized_users` forces the creation of a new Linode Instance.*
        /// </summary>
        public readonly ImmutableArray<string> AuthorizedUsers;
        public readonly string Filesystem;
        /// <summary>
        /// The ID of the disk in the Linode API.
        /// </summary>
        public readonly int Id;
        /// <summary>
        /// An Image ID to deploy the Disk from. Official Linode Images start with linode/, while your Images start with private/. See /images for more information on the Images available for you to use. Examples are `linode/debian9`, `linode/fedora28`, `linode/ubuntu16.04lts`, `linode/arch`, and `private/12345`. *Changing `image` forces the creation of a new Linode Instance.*
        /// </summary>
        public readonly string Image;
        /// <summary>
        /// The Config's label for display purposes.  Also used by `boot_config_label`.
        /// </summary>
        public readonly string Label;
        public readonly bool ReadOnly;
        public readonly string? RootPass;
        /// <summary>
        /// The size of the Disk in MB.
        /// </summary>
        public readonly int Size;
        /// <summary>
        /// An object containing responses to any User Defined Fields present in the StackScript being deployed to this Linode. Only accepted if 'stackscript_id' is given. The required values depend on the StackScript being deployed.  *This value can not be imported.* *Changing `stackscript_data` forces the creation of a new Linode Instance.*
        /// </summary>
        public readonly ImmutableDictionary<string, object> StackscriptData;
        /// <summary>
        /// The StackScript to deploy to the newly created Linode. If provided, 'image' must also be provided, and must be an Image that is compatible with this StackScript. *This value can not be imported.* *Changing `stackscript_id` forces the creation of a new Linode Instance.*
        /// </summary>
        public readonly int StackscriptId;

        [OutputConstructor]
        private InstanceDisks(
            ImmutableArray<string> authorizedKeys,
            ImmutableArray<string> authorizedUsers,
            string filesystem,
            int id,
            string image,
            string label,
            bool readOnly,
            string? rootPass,
            int size,
            ImmutableDictionary<string, object> stackscriptData,
            int stackscriptId)
        {
            AuthorizedKeys = authorizedKeys;
            AuthorizedUsers = authorizedUsers;
            Filesystem = filesystem;
            Id = id;
            Image = image;
            Label = label;
            ReadOnly = readOnly;
            RootPass = rootPass;
            Size = size;
            StackscriptData = stackscriptData;
            StackscriptId = stackscriptId;
        }
    }

    [OutputType]
    public sealed class InstanceSpecs
    {
        public readonly int Disk;
        public readonly int Memory;
        public readonly int Transfer;
        public readonly int Vcpus;

        [OutputConstructor]
        private InstanceSpecs(
            int disk,
            int memory,
            int transfer,
            int vcpus)
        {
            Disk = disk;
            Memory = memory;
            Transfer = transfer;
            Vcpus = vcpus;
        }
    }
    }
}
